// Generated by CoffeeScript 1.9.3
(function() {
  'use strict';
  var BLOCK_SIZE, Datx, HEADER_SIZE, IP_MASK, LEN_OFFSET, PARTITION_FACTOR, VERSION_OFFSET, long2ip;

  long2ip = require('./utils').long2ip;

  HEADER_SIZE = 0x40000;

  IP_MASK = 0xFF000000;

  BLOCK_SIZE = 9;

  PARTITION_FACTOR = 24;

  LEN_OFFSET = 8;

  VERSION_OFFSET = 4294967040;


  /**
   * Driver for datx format provided by ipip.net
   * @param {Buffer} buffer file content
   */

  Datx = function(buffer) {
    this.buffer = buffer;
    this.len = buffer.readInt32BE(0);
  };


  /**
   * Get database information
   */

  Datx.prototype.info = function() {
    var ret, version;
    ret = {
      items: this.len
    };
    version = this.lookup(VERSION_OFFSET);
    if (version && version[0] === 'IPIP.NET') {
      ret.version = version[1];
    }
    return ret;
  };


  /**
   * lookup an ip
   * @param  {Integer} ip IPv4 address in int
   * @return {Array}    lookup result
   */

  Datx.prototype.lookup = function(ip) {
    var a, b, ceil, floor, high, index, low, mid, offset, partition, recordLength, recordOffset;
    partition = ip & IP_MASK;
    partition = partition >>> PARTITION_FACTOR;
    floor = this.buffer.readInt32LE(partition + 4) * BLOCK_SIZE + HEADER_SIZE;
    ceil = this.len - HEADER_SIZE - 4;
    low = 0;
    high = Math.floor((ceil - floor) / BLOCK_SIZE);
    mid = void 0;
    while (low <= high) {
      mid = low + high >>> 1;
      offset = floor + mid * BLOCK_SIZE + 4;
      a = this.buffer.readInt32BE(offset) >>> 0;
      b = this.buffer.readInt32BE(offset + BLOCK_SIZE) >>> 0;
      if (b < ip) {
        low = mid + 1;
      } else if (a > ip) {
        high = mid - 1;
      } else {
        offset += BLOCK_SIZE;
        index = this.buffer.readInt32LE(offset + 4) >>> 0;
        recordOffset = (index & 0x00FFFFFF) + this.len - HEADER_SIZE;
        recordLength = this.buffer.readUInt8(offset + LEN_OFFSET);
        return [long2ip(a + 1), long2ip(b)].concat(this.buffer.slice(recordOffset, recordOffset + recordLength).toString().split('\t'));
      }
    }
    return null;
  };


  /**
   * record columns
   * @type {Array}
   */

  Datx.prototype.columns = ['from', 'to', 'country', 'province', 'city', 'organization', 'isp', 'latitude', 'longitude', 'timezone', 'timezone2', 'postal_code', 'country_code', 'country_abbr', 'region'];

  module.exports = Datx;

}).call(this);
